AI使用说明

# AI在哪些关键地方提供了帮助？
- 题目给的需求描述到具体的PRD。AI考虑的比我更全一些
- 整体MVP项目的代码生成：利用Trae SOLO Coder MAX模式【with 模型Gemini 3 Pro】
- 中间件推荐：
  - 消息队列：Kafka、RabbitMQ、RocketMQ选型。
  - 打点系统选型：OpenTelemetry、Prometheus Client + Grafana。
- 提出了一些让系统更佳健壮性的建议：
    - 可以考虑死信队列保留那些重试也无法发出去的事件。
    - 可以考虑使用指数退避重试策略而不是固定时间的重试。

# AI给出过哪些我没有采纳的建议？
- 第一次生成代码时，AI为了防止系统宕机后数据丢失，采用了本地SQLLite数据库存储。但是线上机器大部分都是分布式，而且消息没有被消费短时间也不会丢失，所以这里没有必要采用本地数据库。

# 哪些关键决策是我做出的，以及原因
- 事件处理逻辑配置化：可能是之前做过配置化类似项目，我第一眼就觉得这里可以抽象成配置化逻辑。原因是因为这样可以很方便地添加新的事件类型，而不需要修改代码。同时处理逻辑清晰，易于维护。
- 选择使用消息队列：解耦 + 削峰，增加系统的吞吐量和稳定性。原因是消息队列可以控制消费速率，万一有些下游不支持很高的QPS，消息队列可以缓冲这些请求同时设置限流，避免系统崩溃。
- 监控打点：在事件处理服务中添加监控打点，比如记录每个事件的处理时间、成功数、失败数等。这样可以方便地监控系统的运行状态，及时发现问题。
- 消息队列中间件的选择：最终选择了RocketMQ，支持延迟和定时消息，同时原生支持死信队列。相较于Kafka而言生态更加完善。